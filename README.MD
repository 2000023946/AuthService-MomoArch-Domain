# ğŸ›¡ï¸ AuthService Domain  
## The **Requirement Architecture** Standard

> **â€œA boolean is a guess. A Proof is a certainty.â€**

---

## ğŸ“Œ Overview

This repository contains the **Domain Layer** of an enterprise-grade **Authentication Microservice**, implemented using **Domain-Driven Design (DDD)** and **Clean Architecture** principles.

At its core is a custom architectural standard known as **Requirement-Architecture** â€” a **Proof-Oriented, Capability-Based Security Model** designed to eliminate *implicit trust* from the domain.

Instead of relying on unchecked primitives (booleans, raw strings, timestamps), the domain operates exclusively on **certified proofs** that guarantee correctness, authorization, and origin at **compile time** and **runtime**.

---

## ğŸš€ Key Architectural Pillars

### 1ï¸âƒ£ The Triple-Lock Handshake (1-1-1 Relationship)

Every Domain Aggregate is created or reconstituted through a strict **1-1-1 binding** between:

- **Requirement**  
  A capability-guarded *Vault* containing raw input (Schema or Proof).  
  Holds a **hard reference** to its authorized Factory.

- **Factory**  
  The **only** component permitted to unlock and consume a Requirement.

- **Proof**  
  A domain-certified receipt proving the Aggregate was created from a valid source.

> An Aggregate **cannot exist** without all three.

![Picture Depicting the Triple-Lock Handshake](3.png)

---

### 2ï¸âƒ£ Proof-Oriented Design

In this domain, **state transitions emit certificates**.

Examples include:

- **Birth Proofs**
  - `UserRegistrationProof`
  - `LoginProof`

- **Lifecycle Proofs**
  - `SessionActiveProof`
  - `SessionDeactivationProof`
  - `TokenDeactivationProof`

These proofs are:
- Immutable
- Non-forgeable
- Observable by infrastructure layers
- Auditable by design

The domain does not â€œcheck flagsâ€ â€” it **verifies history**.

![Picture Describing how the modules interact. Shows the high level Implementation of the Architecture](generalFlow.png)
---

### 3ï¸âƒ£ Agile Invariant Enforcement

Business rules are enforced at the **compiler level** using:

- Recursive generics
- Visibility-gated constructors
- Capability-restricted factories

If a developer attempts to:
- Create a `Session` without a `LoginProof`
- Reconstitute a `Token` without validated claims

â¡ï¸ **The code will not compile.**

This enables **fearless refactoring** of security-critical logic.

![Picture Describing The creation of Refresh Token and how the requirement allows easy enforcement of Domain Rules](specificFlow.png)
---

### âš™ï¸ FSM & Internal DSL

This domain implements a **Proof-Carrying Finite State Machine (FSM)** and acts as a **compiler-enforced internal DSL**:

- **FSM:** Every Aggregate transition emits an immutable **Proof**, ensuring invalid states are impossible.
- **DSL:** Domain rules are expressed via **Requirements â†’ Factories â†’ Proofs**, making violations unrepresentable in code.

This makes **causal correctness** and **business invariants** explicit and automatically enforced.


## Some Diagrams Used to help understand the domain
EERD 
![EERD of the Domain](eerd.png)
UML
![UML of the Domain](uml.png)
---

## ğŸ“‚ Project Structure

```text
â”œâ”€â”€ model/
â”‚   â”œâ”€â”€ aggregates/      # Triple-Lock handshake implementations
â”‚   â”‚   â”œâ”€â”€ user/        # Identity aggregates
â”‚   â”‚   â”œâ”€â”€ session/     # Lifecycle & deactivation proofs
â”‚   â”‚   â””â”€â”€ token/       # 3NF-aligned hierarchical tokens
â”‚   â”œâ”€â”€ services/        # Credential & MFA validation gateway
â”‚   â”œâ”€â”€ schemas/         # Persistence reconstitution specs
â”‚   â”œâ”€â”€ mapping/         # Object â†” schema transformation
â”‚   â”œâ”€â”€ parser/          # JWT & opaque token parsing engines
â”‚   â””â”€â”€ valueobjects/    # Immutable domain primitives
â”œâ”€â”€ ports/               # Infrastructure contracts
â””â”€â”€ exceptions/          # Domain-specific error hierarchy
